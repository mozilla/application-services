diff --git a/components/suggest/android/build.gradle b/components/suggest/android/build.gradle
index 09056f3a91..70bc549387 100644
--- a/components/suggest/android/build.gradle
+++ b/components/suggest/android/build.gradle
@@ -7,6 +7,8 @@
 
 dependencies {
     api project(":remotesettings")
+
+    implementation libs.kotlinx.coroutines
 }
 
 ext.configureUniFFIBindgen("suggest")
diff --git a/components/suggest/src/db.rs b/components/suggest/src/db.rs
index dcde6f7c85..fc1d22cf05 100644
--- a/components/suggest/src/db.rs
+++ b/components/suggest/src/db.rs
@@ -113,18 +113,38 @@
         }
     }
 
+    pub fn begin_interrupt_scope(&self) -> Result<SqlInterruptScope> {
+        Ok(self.interrupt_handle.begin_interrupt_scope()?)
+    }
+
     /// Accesses the Suggest database for reading.
     pub fn read<T>(&self, op: impl FnOnce(&SuggestDao) -> Result<T>) -> Result<T> {
+        self.read_with_scope(self.interrupt_handle.begin_interrupt_scope()?, op)
+    }
+
+    /// Like [Self::read], but inputs a previously created `SqlInterruptScope` to use
+    pub fn read_with_scope<T>(
+        &self,
+        scope: SqlInterruptScope,
+        op: impl FnOnce(&SuggestDao) -> Result<T>,
+    ) -> Result<T> {
         let conn = self.conn.lock();
-        let scope = self.interrupt_handle.begin_interrupt_scope()?;
         let dao = SuggestDao::new(&conn, &scope);
         op(&dao)
     }
 
     /// Accesses the Suggest database in a transaction for reading and writing.
     pub fn write<T>(&self, op: impl FnOnce(&mut SuggestDao) -> Result<T>) -> Result<T> {
+        self.write_with_scope(self.interrupt_handle.begin_interrupt_scope()?, op)
+    }
+
+    /// Like [Self::write], but inputs a previously created `SqlInterruptScope` to use
+    pub fn write_with_scope<T>(
+        &self,
+        scope: SqlInterruptScope,
+        op: impl FnOnce(&mut SuggestDao) -> Result<T>,
+    ) -> Result<T> {
         let mut conn = self.conn.lock();
-        let scope = self.interrupt_handle.begin_interrupt_scope()?;
         let tx = conn.transaction()?;
         let mut dao = SuggestDao::new(&tx, &scope);
         let result = op(&mut dao)?;
diff --git a/components/suggest/src/store.rs b/components/suggest/src/store.rs
index c61531908b..e83a228293 100644
--- a/components/suggest/src/store.rs
+++ b/components/suggest/src/store.rs
@@ -10,9 +10,11 @@
 };
 
 use error_support::{breadcrumb, handle_error};
+use interrupt_support::SqlInterruptScope;
 use once_cell::sync::OnceCell;
 use parking_lot::Mutex;
 use remote_settings::{self, RemoteSettingsConfig, RemoteSettingsServer};
+use uniffi::{run_in_background, WorkerQueue};
 
 use serde::de::DeserializeOwned;
 
@@ -116,6 +118,30 @@
             inner: SuggestStoreInner::new(data_path, extensions_to_load, client),
         }))
     }
+
+    #[handle_error(Error)]
+    pub fn build_async(
+        &self,
+        worker_queue: Arc<dyn WorkerQueue>,
+    ) -> SuggestApiResult<Arc<SuggestStoreAsync>> {
+        let inner = self.0.lock();
+        let extensions_to_load = inner.extensions_to_load.clone();
+        let data_path = inner
+            .data_path
+            .clone()
+            .ok_or_else(|| Error::SuggestStoreBuilder("data_path not specified".to_owned()))?;
+
+        let client = RemoteSettingsClient::new(
+            inner.remote_settings_server.clone(),
+            inner.remote_settings_bucket_name.clone(),
+            None,
+        )?;
+
+        Ok(Arc::new(SuggestStoreAsync {
+            worker_queue,
+            inner: SuggestStoreInner::new(data_path, extensions_to_load, client),
+        }))
+    }
 }
 
 /// What should be interrupted when [SuggestStore::interrupt] is called?
@@ -192,7 +218,10 @@
     /// Queries the database for suggestions.
     #[handle_error(Error)]
     pub fn query(&self, query: SuggestionQuery) -> SuggestApiResult<Vec<Suggestion>> {
-        Ok(self.inner.query(query)?.suggestions)
+        Ok(self
+            .inner
+            .query(query, self.inner.begin_reader_scope()?)?
+            .suggestions)
     }
 
     /// Queries the database for suggestions.
@@ -201,7 +230,7 @@
         &self,
         query: SuggestionQuery,
     ) -> SuggestApiResult<QueryWithMetricsResult> {
-        self.inner.query(query)
+        self.inner.query(query, self.inner.begin_reader_scope()?)
     }
 
     /// Dismiss a suggestion
@@ -312,6 +341,159 @@
     }
 }
 
+/// Suggest store where all the methods are async
+///
+/// This duplicates the functionality from [SuggestStore], but exposes it as async methods.
+/// The plan is to migrate consumers over to this interface, then remove the old one.
+#[derive(uniffi::Object)]
+pub struct SuggestStoreAsync {
+    worker_queue: Arc<dyn WorkerQueue>,
+    inner: SuggestStoreInner<RemoteSettingsClient>,
+}
+
+impl SuggestStoreAsync {
+    async fn wrap_method_call<T, F>(self: Arc<Self>, f: F) -> SuggestApiResult<T>
+    where
+        F: FnOnce(&SuggestStoreInner<RemoteSettingsClient>) -> Result<T>,
+        F: Send + Sync + 'static,
+        T: Send + Sync + 'static,
+    {
+        run_in_background(self.worker_queue.clone(), move || f(&self.inner))
+            .await
+            .map_err(error_support::convert_log_report_error)
+    }
+}
+#[uniffi::export]
+impl SuggestStoreAsync {
+    pub async fn query(
+        self: Arc<Self>,
+        query: SuggestionQuery,
+    ) -> SuggestApiResult<Vec<Suggestion>> {
+        // Create the interrupt scope before `wrap_method_call`, this way we'll interrupts that
+        // happen after the query was scheduled, but before it was executed.
+        let scope = self
+            .inner
+            .begin_reader_scope()
+            .map_err(error_support::convert_log_report_error)?;
+        self.wrap_method_call(move |inner| Ok(inner.query(query, scope)?.suggestions))
+            .await
+    }
+
+    /// Queries the database for suggestions.
+    pub async fn query_with_metrics(
+        self: Arc<Self>,
+        query: SuggestionQuery,
+    ) -> SuggestApiResult<QueryWithMetricsResult> {
+        let scope = self
+            .inner
+            .begin_reader_scope()
+            .map_err(error_support::convert_log_report_error)?;
+        self.wrap_method_call(move |inner| inner.query(query, scope))
+            .await
+    }
+
+    /// Dismiss a suggestion
+    ///
+    /// Dismissed suggestions will not be returned again
+    ///
+    /// In the case of AMP suggestions this should be the raw URL.
+    pub async fn dismiss_suggestion(
+        self: Arc<Self>,
+        suggestion_url: String,
+    ) -> SuggestApiResult<()> {
+        self.wrap_method_call(move |inner| inner.dismiss_suggestion(suggestion_url))
+            .await
+    }
+
+    /// Clear dismissed suggestions
+    pub async fn clear_dismissed_suggestions(self: Arc<Self>) -> SuggestApiResult<()> {
+        self.wrap_method_call(|inner| inner.clear_dismissed_suggestions())
+            .await
+    }
+
+    /// Interrupts any ongoing queries.
+    ///
+    /// This should be called when the user types new input into the address
+    /// bar, to ensure that they see fresh suggestions as they type. This
+    /// method does not interrupt any ongoing ingests.
+    ///
+    /// Note: this method is not async, since the goal is to preempt currently running async
+    /// operations.
+    #[uniffi::method(default(kind = None))]
+    pub fn interrupt(self: Arc<Self>, kind: Option<InterruptKind>) {
+        self.inner.interrupt(kind)
+    }
+
+    /// Ingests new suggestions from Remote Settings.
+    ///
+    /// Returns `true` if the ingest succeeded, `false` if it needs to be tried again
+    #[uniffi::method(default(constraints = None))]
+    pub async fn ingest(self: Arc<Self>, constraints: Option<SuggestIngestionConstraints>) -> bool {
+        let constraints = constraints.unwrap_or_default();
+        self.wrap_method_call(move |inner| inner.ingest(constraints))
+            .await
+            // Use `is_ok` to squash errors and return a boolean instead.
+            // Note: errors are logged by the call to `convert_log_report_error`
+            .is_ok()
+    }
+
+    /// Removes all content from the database.
+    pub async fn clear(self: Arc<Self>) -> SuggestApiResult<()> {
+        self.wrap_method_call(move |inner| inner.clear()).await
+    }
+
+    /// Returns global Suggest configuration data.
+    pub async fn fetch_global_config(self: Arc<Self>) -> SuggestApiResult<SuggestGlobalConfig> {
+        self.wrap_method_call(move |inner| inner.fetch_global_config())
+            .await
+    }
+
+    /// Returns per-provider Suggest configuration data.
+    pub async fn fetch_provider_config(
+        self: Arc<Self>,
+        provider: SuggestionProvider,
+    ) -> SuggestApiResult<Option<SuggestProviderConfig>> {
+        self.wrap_method_call(move |inner| inner.fetch_provider_config(provider))
+            .await
+    }
+
+    /// Fetches geonames stored in the database. A geoname represents a
+    /// geographic place.
+    ///
+    /// `query` is a string that will be matched directly against geoname names.
+    /// It is not a query string in the usual Suggest sense. `match_name_prefix`
+    /// determines whether prefix matching is performed on names excluding
+    /// abbreviations and airport codes. When `true`, names that start with
+    /// `query` will match. When false, names that equal `query` will match.
+    ///
+    /// `geoname_type` restricts returned geonames to a [`GeonameType`].
+    ///
+    /// `filter` restricts returned geonames to certain cities or regions.
+    /// Cities can be restricted to regions by including the regions in
+    /// `filter`, and regions can be restricted to those containing certain
+    /// cities by including the cities in `filter`. This is especially useful
+    /// since city and region names are not unique. `filter` is disjunctive: If
+    /// any item in `filter` matches a geoname, the geoname will be filtered in.
+    ///
+    /// The query can match a single geoname in more than one way. For example,
+    /// it can match both a full name and an abbreviation. The returned vec of
+    /// [`GeonameMatch`] values will include all matches for a geoname, one
+    /// match per `match_type` per geoname. In other words, a matched geoname
+    /// can map to more than one `GeonameMatch`.
+    pub async fn fetch_geonames(
+        self: Arc<Self>,
+        query: String,
+        match_name_prefix: bool,
+        geoname_type: Option<GeonameType>,
+        filter: Option<Vec<Geoname>>,
+    ) -> SuggestApiResult<Vec<GeonameMatch>> {
+        self.wrap_method_call(move |inner| {
+            inner.fetch_geonames(&query, match_name_prefix, geoname_type, filter)
+        })
+        .await
+    }
+}
+
 /// Constraints limit which suggestions to ingest from Remote Settings.
 #[derive(Clone, Default, Debug, uniffi::Record)]
 pub struct SuggestIngestionConstraints {
@@ -399,15 +581,27 @@
             .get_or_try_init(|| SuggestStoreDbs::open(&self.data_path, &self.extensions_to_load))
     }
 
-    fn query(&self, query: SuggestionQuery) -> Result<QueryWithMetricsResult> {
+    fn begin_reader_scope(&self) -> Result<SqlInterruptScope> {
+        self.dbs()?.reader.begin_interrupt_scope()
+    }
+
+    fn query(
+        &self,
+        query: SuggestionQuery,
+        scope: SqlInterruptScope,
+    ) -> Result<QueryWithMetricsResult> {
+        // Before anything, check if the scope was interrupted.  This handles the case where query
+        // scheduled by SuggestStoreAsync was interrupted.
+        scope.err_if_interrupted()?;
         let mut metrics = SuggestQueryMetrics::default();
         let mut suggestions = vec![];
 
         let unique_providers = query.providers.iter().collect::<HashSet<_>>();
         let reader = &self.dbs()?.reader;
         for provider in unique_providers {
+            let scope = scope.clone();
             let new_suggestions = metrics.measure_query(provider.to_string(), || {
-                reader.read(|dao| match provider {
+                reader.read_with_scope(scope, |dao| match provider {
                     SuggestionProvider::Amp => {
                         dao.fetch_amp_suggestions(&query, AmpSuggestionType::Desktop)
                     }
@@ -950,7 +1144,8 @@
         }
 
         pub fn fetch_suggestions(&self, query: SuggestionQuery) -> Vec<Suggestion> {
-            self.inner.query(query).unwrap().suggestions
+            let scope = self.inner.begin_reader_scope().unwrap();
+            self.inner.query(query, scope).unwrap().suggestions
         }
 
         pub fn fetch_global_config(&self) -> SuggestGlobalConfig {
diff --git a/components/support/interrupt/src/sql.rs b/components/support/interrupt/src/sql.rs
index af97a6e1c6..5e8e1821e1 100644
--- a/components/support/interrupt/src/sql.rs
+++ b/components/support/interrupt/src/sql.rs
@@ -75,7 +75,7 @@
 ///
 /// This is used by the rust code to check if an operation should fail because it was interrupted.
 /// It handles the case where we get interrupted outside of an SQL query.
-#[derive(Debug)]
+#[derive(Clone, Debug)]
 pub struct SqlInterruptScope {
     start_value: usize,
     interrupt_counter: Arc<AtomicUsize>,
