diff --git a/Cargo.lock b/Cargo.lock
index c1171dad5d..b99fbfc825 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3431,6 +3431,12 @@
 ]
 
 [[package]]
+name = "oneshot"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e296cf87e61c9cfc1a61c3c63a0f7f286ed4554e0e22be84e8a38e1d264a2a29"
+
+[[package]]
 name = "oorandom"
 version = "11.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
@@ -4870,6 +4876,7 @@
  "interrupt-support",
  "log",
  "once_cell",
+ "oneshot",
  "parking_lot",
  "rc_crypto",
  "remote_settings",
diff --git a/components/suggest/Cargo.toml b/components/suggest/Cargo.toml
index 241b332798..f68cb5ae64 100644
--- a/components/suggest/Cargo.toml
+++ b/components/suggest/Cargo.toml
@@ -15,6 +15,7 @@
 interrupt-support = { path = "../support/interrupt" }
 log = "0.4"
 once_cell = "1.5"
+oneshot = "0.1.8"
 parking_lot = ">=0.11,<=0.12"
 remote_settings = { path = "../remote_settings" }
 rusqlite = { version = "0.31.0", features = ["functions", "bundled", "load_extension"] }
diff --git a/components/suggest/android/build.gradle b/components/suggest/android/build.gradle
index 09056f3a91..70bc549387 100644
--- a/components/suggest/android/build.gradle
+++ b/components/suggest/android/build.gradle
@@ -7,6 +7,8 @@
 
 dependencies {
     api project(":remotesettings")
+
+    implementation libs.kotlinx.coroutines
 }
 
 ext.configureUniFFIBindgen("suggest")
diff --git a/components/suggest/src/db.rs b/components/suggest/src/db.rs
index dcde6f7c85..fc1d22cf05 100644
--- a/components/suggest/src/db.rs
+++ b/components/suggest/src/db.rs
@@ -113,18 +113,38 @@
         }
     }
 
+    pub fn begin_interrupt_scope(&self) -> Result<SqlInterruptScope> {
+        Ok(self.interrupt_handle.begin_interrupt_scope()?)
+    }
+
     /// Accesses the Suggest database for reading.
     pub fn read<T>(&self, op: impl FnOnce(&SuggestDao) -> Result<T>) -> Result<T> {
+        self.read_with_scope(self.interrupt_handle.begin_interrupt_scope()?, op)
+    }
+
+    /// Like [Self::read], but inputs a previously created `SqlInterruptScope` to use
+    pub fn read_with_scope<T>(
+        &self,
+        scope: SqlInterruptScope,
+        op: impl FnOnce(&SuggestDao) -> Result<T>,
+    ) -> Result<T> {
         let conn = self.conn.lock();
-        let scope = self.interrupt_handle.begin_interrupt_scope()?;
         let dao = SuggestDao::new(&conn, &scope);
         op(&dao)
     }
 
     /// Accesses the Suggest database in a transaction for reading and writing.
     pub fn write<T>(&self, op: impl FnOnce(&mut SuggestDao) -> Result<T>) -> Result<T> {
+        self.write_with_scope(self.interrupt_handle.begin_interrupt_scope()?, op)
+    }
+
+    /// Like [Self::write], but inputs a previously created `SqlInterruptScope` to use
+    pub fn write_with_scope<T>(
+        &self,
+        scope: SqlInterruptScope,
+        op: impl FnOnce(&mut SuggestDao) -> Result<T>,
+    ) -> Result<T> {
         let mut conn = self.conn.lock();
-        let scope = self.interrupt_handle.begin_interrupt_scope()?;
         let tx = conn.transaction()?;
         let mut dao = SuggestDao::new(&tx, &scope);
         let result = op(&mut dao)?;
diff --git a/components/suggest/src/lib.rs b/components/suggest/src/lib.rs
index 689f39a57b..b9374e6daf 100644
--- a/components/suggest/src/lib.rs
+++ b/components/suggest/src/lib.rs
@@ -18,6 +18,7 @@
 mod schema;
 mod store;
 mod suggestion;
+mod taskqueue;
 #[cfg(test)]
 mod testing;
 pub mod util;
diff --git a/components/suggest/src/store.rs b/components/suggest/src/store.rs
index c61531908b..12afe1ee91 100644
--- a/components/suggest/src/store.rs
+++ b/components/suggest/src/store.rs
@@ -10,6 +10,7 @@
 };
 
 use error_support::{breadcrumb, handle_error};
+use interrupt_support::SqlInterruptScope;
 use once_cell::sync::OnceCell;
 use parking_lot::Mutex;
 use remote_settings::{self, RemoteSettingsConfig, RemoteSettingsServer};
@@ -28,6 +29,7 @@
         SuggestAttachment, SuggestRecord, SuggestRecordId, SuggestRecordType,
     },
     suggestion::AmpSuggestionType,
+    taskqueue::{run_in_background, WorkerQueue},
     QueryWithMetricsResult, Result, SuggestApiResult, Suggestion, SuggestionQuery,
 };
 
@@ -116,6 +118,30 @@
             inner: SuggestStoreInner::new(data_path, extensions_to_load, client),
         }))
     }
+
+    #[handle_error(Error)]
+    pub fn build_async(
+        &self,
+        worker_queue: Arc<dyn WorkerQueue>,
+    ) -> SuggestApiResult<Arc<SuggestStoreAsync>> {
+        let inner = self.0.lock();
+        let extensions_to_load = inner.extensions_to_load.clone();
+        let data_path = inner
+            .data_path
+            .clone()
+            .ok_or_else(|| Error::SuggestStoreBuilder("data_path not specified".to_owned()))?;
+
+        let client = RemoteSettingsClient::new(
+            inner.remote_settings_server.clone(),
+            inner.remote_settings_bucket_name.clone(),
+            None,
+        )?;
+
+        Ok(Arc::new(SuggestStoreAsync {
+            worker_queue,
+            inner: SuggestStoreInner::new(data_path, extensions_to_load, client),
+        }))
+    }
 }
 
 /// What should be interrupted when [SuggestStore::interrupt] is called?
@@ -192,7 +218,10 @@
     /// Queries the database for suggestions.
     #[handle_error(Error)]
     pub fn query(&self, query: SuggestionQuery) -> SuggestApiResult<Vec<Suggestion>> {
-        Ok(self.inner.query(query)?.suggestions)
+        Ok(self
+            .inner
+            .query(query, self.inner.begin_reader_scope()?)?
+            .suggestions)
     }
 
     /// Queries the database for suggestions.
@@ -201,7 +230,7 @@
         &self,
         query: SuggestionQuery,
     ) -> SuggestApiResult<QueryWithMetricsResult> {
-        self.inner.query(query)
+        self.inner.query(query, self.inner.begin_reader_scope()?)
     }
 
     /// Dismiss a suggestion
@@ -312,6 +341,159 @@
     }
 }
 
+/// Suggest store where all the methods are async
+///
+/// This duplicates the functionality from [SuggestStore], but exposes it as async methods.
+/// The plan is to migrate consumers over to this interface, then remove the old one.
+#[derive(uniffi::Object)]
+pub struct SuggestStoreAsync {
+    worker_queue: Arc<dyn WorkerQueue>,
+    inner: SuggestStoreInner<RemoteSettingsClient>,
+}
+
+impl SuggestStoreAsync {
+    async fn wrap_method_call<T, F>(self: Arc<Self>, f: F) -> SuggestApiResult<T>
+    where
+        F: FnOnce(&SuggestStoreInner<RemoteSettingsClient>) -> Result<T>,
+        F: Send + Sync + 'static,
+        T: Send + Sync + 'static,
+    {
+        run_in_background(self.worker_queue.clone(), move || f(&self.inner))
+            .await
+            .map_err(error_support::convert_log_report_error)
+    }
+}
+#[uniffi::export]
+impl SuggestStoreAsync {
+    pub async fn query(
+        self: Arc<Self>,
+        query: SuggestionQuery,
+    ) -> SuggestApiResult<Vec<Suggestion>> {
+        // Create the interrupt scope before `wrap_method_call`, this way we'll interrupts that
+        // happen after the query was scheduled, but before it was executed.
+        let scope = self
+            .inner
+            .begin_reader_scope()
+            .map_err(error_support::convert_log_report_error)?;
+        self.wrap_method_call(move |inner| Ok(inner.query(query, scope)?.suggestions))
+            .await
+    }
+
+    /// Queries the database for suggestions.
+    pub async fn query_with_metrics(
+        self: Arc<Self>,
+        query: SuggestionQuery,
+    ) -> SuggestApiResult<QueryWithMetricsResult> {
+        let scope = self
+            .inner
+            .begin_reader_scope()
+            .map_err(error_support::convert_log_report_error)?;
+        self.wrap_method_call(move |inner| inner.query(query, scope))
+            .await
+    }
+
+    /// Dismiss a suggestion
+    ///
+    /// Dismissed suggestions will not be returned again
+    ///
+    /// In the case of AMP suggestions this should be the raw URL.
+    pub async fn dismiss_suggestion(
+        self: Arc<Self>,
+        suggestion_url: String,
+    ) -> SuggestApiResult<()> {
+        self.wrap_method_call(move |inner| inner.dismiss_suggestion(suggestion_url))
+            .await
+    }
+
+    /// Clear dismissed suggestions
+    pub async fn clear_dismissed_suggestions(self: Arc<Self>) -> SuggestApiResult<()> {
+        self.wrap_method_call(|inner| inner.clear_dismissed_suggestions())
+            .await
+    }
+
+    /// Interrupts any ongoing queries.
+    ///
+    /// This should be called when the user types new input into the address
+    /// bar, to ensure that they see fresh suggestions as they type. This
+    /// method does not interrupt any ongoing ingests.
+    ///
+    /// Note: this method is not async, since the goal is to preempt currently running async
+    /// operations.
+    #[uniffi::method(default(kind = None))]
+    pub fn interrupt(self: Arc<Self>, kind: Option<InterruptKind>) {
+        self.inner.interrupt(kind)
+    }
+
+    /// Ingests new suggestions from Remote Settings.
+    ///
+    /// Returns `true` if the ingest succeeded, `false` if it needs to be tried again
+    #[uniffi::method(default(constraints = None))]
+    pub async fn ingest(self: Arc<Self>, constraints: Option<SuggestIngestionConstraints>) -> bool {
+        let constraints = constraints.unwrap_or_default();
+        self.wrap_method_call(move |inner| inner.ingest(constraints))
+            .await
+            // Use `is_ok` to squash errors and return a boolean instead.
+            // Note: errors are logged by the call to `convert_log_report_error`
+            .is_ok()
+    }
+
+    /// Removes all content from the database.
+    pub async fn clear(self: Arc<Self>) -> SuggestApiResult<()> {
+        self.wrap_method_call(move |inner| inner.clear()).await
+    }
+
+    /// Returns global Suggest configuration data.
+    pub async fn fetch_global_config(self: Arc<Self>) -> SuggestApiResult<SuggestGlobalConfig> {
+        self.wrap_method_call(move |inner| inner.fetch_global_config())
+            .await
+    }
+
+    /// Returns per-provider Suggest configuration data.
+    pub async fn fetch_provider_config(
+        self: Arc<Self>,
+        provider: SuggestionProvider,
+    ) -> SuggestApiResult<Option<SuggestProviderConfig>> {
+        self.wrap_method_call(move |inner| inner.fetch_provider_config(provider))
+            .await
+    }
+
+    /// Fetches geonames stored in the database. A geoname represents a
+    /// geographic place.
+    ///
+    /// `query` is a string that will be matched directly against geoname names.
+    /// It is not a query string in the usual Suggest sense. `match_name_prefix`
+    /// determines whether prefix matching is performed on names excluding
+    /// abbreviations and airport codes. When `true`, names that start with
+    /// `query` will match. When false, names that equal `query` will match.
+    ///
+    /// `geoname_type` restricts returned geonames to a [`GeonameType`].
+    ///
+    /// `filter` restricts returned geonames to certain cities or regions.
+    /// Cities can be restricted to regions by including the regions in
+    /// `filter`, and regions can be restricted to those containing certain
+    /// cities by including the cities in `filter`. This is especially useful
+    /// since city and region names are not unique. `filter` is disjunctive: If
+    /// any item in `filter` matches a geoname, the geoname will be filtered in.
+    ///
+    /// The query can match a single geoname in more than one way. For example,
+    /// it can match both a full name and an abbreviation. The returned vec of
+    /// [`GeonameMatch`] values will include all matches for a geoname, one
+    /// match per `match_type` per geoname. In other words, a matched geoname
+    /// can map to more than one `GeonameMatch`.
+    pub async fn fetch_geonames(
+        self: Arc<Self>,
+        query: String,
+        match_name_prefix: bool,
+        geoname_type: Option<GeonameType>,
+        filter: Option<Vec<Geoname>>,
+    ) -> SuggestApiResult<Vec<GeonameMatch>> {
+        self.wrap_method_call(move |inner| {
+            inner.fetch_geonames(&query, match_name_prefix, geoname_type, filter)
+        })
+        .await
+    }
+}
+
 /// Constraints limit which suggestions to ingest from Remote Settings.
 #[derive(Clone, Default, Debug, uniffi::Record)]
 pub struct SuggestIngestionConstraints {
@@ -399,15 +581,27 @@
             .get_or_try_init(|| SuggestStoreDbs::open(&self.data_path, &self.extensions_to_load))
     }
 
-    fn query(&self, query: SuggestionQuery) -> Result<QueryWithMetricsResult> {
+    fn begin_reader_scope(&self) -> Result<SqlInterruptScope> {
+        self.dbs()?.reader.begin_interrupt_scope()
+    }
+
+    fn query(
+        &self,
+        query: SuggestionQuery,
+        scope: SqlInterruptScope,
+    ) -> Result<QueryWithMetricsResult> {
+        // Before anything, check if the scope was interrupted.  This handles the case where query
+        // scheduled by SuggestStoreAsync was interrupted.
+        scope.err_if_interrupted()?;
         let mut metrics = SuggestQueryMetrics::default();
         let mut suggestions = vec![];
 
         let unique_providers = query.providers.iter().collect::<HashSet<_>>();
         let reader = &self.dbs()?.reader;
         for provider in unique_providers {
+            let scope = scope.clone();
             let new_suggestions = metrics.measure_query(provider.to_string(), || {
-                reader.read(|dao| match provider {
+                reader.read_with_scope(scope, |dao| match provider {
                     SuggestionProvider::Amp => {
                         dao.fetch_amp_suggestions(&query, AmpSuggestionType::Desktop)
                     }
@@ -950,7 +1144,8 @@
         }
 
         pub fn fetch_suggestions(&self, query: SuggestionQuery) -> Vec<Suggestion> {
-            self.inner.query(query).unwrap().suggestions
+            let scope = self.inner.begin_reader_scope().unwrap();
+            self.inner.query(query, scope).unwrap().suggestions
         }
 
         pub fn fetch_global_config(&self) -> SuggestGlobalConfig {
diff --git a/components/suggest/src/taskqueue.rs b/components/suggest/src/taskqueue.rs
new file mode 100644
index 0000000000..44231470dc
--- /dev/null
+++ b/components/suggest/src/taskqueue.rs
@@ -1,0 +1,69 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+use std::{future, sync::Arc};
+
+use parking_lot::Mutex;
+
+/// Worker queue scheduler trait
+///
+/// This is implemented by foreign code to schedule blocking Rust tasks:
+///   - On Swift, it's implemented with a `DispatchQueue`
+///   - On Kotlin, it's implemented with a `CoroutineContext`
+///   - On Gecko-JS, it's implemented in Rust using the `moz_task` crate.
+#[uniffi::export(with_foreign)]
+pub trait WorkerQueue: Send + Sync {
+    fn add_task(&self, task: Arc<dyn RustTask>);
+}
+
+#[uniffi::export]
+pub trait RustTask: Send + Sync {
+    fn run(&self);
+}
+
+/// Schedule a closure to run in the global worker queue.  Returns the result of the closure
+/// asynchronously
+pub async fn run_in_background<T: Send + 'static>(
+    worker_queue: Arc<dyn WorkerQueue>,
+    task: impl FnOnce() -> T + Send + Sync + 'static,
+) -> T {
+    let (tx, rx) = oneshot::channel();
+
+    worker_queue.add_task(RustTaskContainer::new_arc(move || {
+        if let Err(e) = tx.send(task()) {
+            error_support::report_error!("suggest-oneshot-send", "{e}");
+        }
+    }));
+    match rx.await {
+        Ok(v) => v,
+        Err(e) => {
+            error_support::report_error!("suggest-oneshot-recv", "{e}");
+            // Not much we can do here other than await forever
+            future::pending().await
+        }
+    }
+}
+
+/// Implements RustTask for any closure
+struct RustTaskContainer<T: FnOnce() + Send> {
+    /// The one tricky part is that the task can only be run once, but the foreign language gets a
+    /// shared reference to it, so put it behind a Mutex + Option
+    task: Mutex<Option<T>>,
+}
+
+impl<T: FnOnce() + Send> RustTaskContainer<T> {
+    fn new_arc(task: T) -> Arc<Self> {
+        Arc::new(Self {
+            task: Mutex::new(Some(task)),
+        })
+    }
+}
+
+impl<T: FnOnce() + Send> RustTask for RustTaskContainer<T> {
+    fn run(&self) {
+        if let Some(f) = self.task.lock().take() {
+            f()
+        }
+    }
+}
diff --git a/components/support/interrupt/src/sql.rs b/components/support/interrupt/src/sql.rs
index af97a6e1c6..5e8e1821e1 100644
--- a/components/support/interrupt/src/sql.rs
+++ b/components/support/interrupt/src/sql.rs
@@ -75,7 +75,7 @@
 ///
 /// This is used by the rust code to check if an operation should fail because it was interrupted.
 /// It handles the case where we get interrupted outside of an SQL query.
-#[derive(Debug)]
+#[derive(Clone, Debug)]
 pub struct SqlInterruptScope {
     start_value: usize,
     interrupt_counter: Arc<AtomicUsize>,
