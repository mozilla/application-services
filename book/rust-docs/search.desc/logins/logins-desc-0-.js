searchState.loadedDescShard("logins", 0, "A bulk insert result entry, returned by <code>add_many</code> and …\nA login stored in the database\nContains the error value\nContains the error value\nLogins error type These are “internal” errors used by …\nError::InvalidLogin subtypes\nA login handed over from the store API, which has been …\nA login handed over to the store API; ie a login not yet …\nA login together with meta fields, handed over to the …\nLogin data specific to database records\nContains the success value\nContains the success value\nLoginEntry fields that are stored encrypted\nAdds multiple logins within a single transaction and …\nAdds multiple logins <strong>including metadata</strong> within a single …\nAdds a login <strong>including metadata</strong>. Normally, you will use <code>add</code>…\nThis method is intended to preserve metadata (LoginMeta) …\nTell the application to log a breadcrumb\nDelete the record with the provided id. Returns true if …\nDelete the records with the specified IDs. Returns a list …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalled by the sync manager to get a sync engine via the …\nA procedural macro that exposes internal errors to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTell the application to report an error\nWipe all local data, returns the number of rows deleted\nThis is the generic EncryptorDecryptor trait, as handed …\nConsumers can implement the KeyManager in combination with …\nThe ManagedEncryptorDecryptor makes use of the NSS …\nUse the <code>NSSKeyManager</code> to use NSS for key management.\n<code>PrimaryPasswordAuthenticator</code> is used in conjunction with …\nLast but not least we provide a StaticKeyManager, which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a primary password for authentication, otherwise …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize new <code>NSSKeyManager</code> with a given …")