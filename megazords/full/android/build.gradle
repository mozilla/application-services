apply plugin: 'com.android.library'
apply plugin: 'org.mozilla.rust-android-gradle.rust-android'
apply plugin: 'kotlin-android'

android {
    namespace 'org.mozilla.appservices.full_megazord'

    ndkVersion rootProject.ext.build.ndkVersion
    compileSdkVersion rootProject.ext.build.compileSdkVersion

    defaultConfig {
        minSdkVersion rootProject.ext.build['minSdkVersion']
        targetSdkVersion rootProject.ext.build['targetSdkVersion']

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
        buildConfigField("String", "LIBRARY_VERSION", "\"${rootProject.ext.library.version}\"")
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            consumerProguardFiles "$rootDir/proguard-rules-consumer-jna.pro"
        }
    }

    // Uncomment to include debug symbols in native library builds.
    // packagingOptions { doNotStrip "**/*.so" }
}

kotlin {
    jvmToolchain(rootProject.ext.build.jvmTargetCompatibility)
}

// Configurations are a somewhat mysterious Gradle concept.  For our purposes, we can treat them
// sets of files produced by one component and consumed by another.
configurations {
    // Libraries for unit tests
    //
    // This is a JAR file that contains libmegazord and libjnidispatch built for desktop platforms
    // -- i.e. non-Android.  These include linux-x86-64, darwin-x86-64, and darwin-aarch64. These
    // libraries are needed to run unit tests, since the AAR packages only contain libraries for
    // Android.
    //
    // For libmegazord, we copy the desktop libs from the
    // [rust-android-gradle plugin](https://github.com/mozilla/rust-android-gradle), which is
    // configurable via `local.properties`. The official packages are built in taskcluster include
    // `linux-x86-64` and `darwin-x86-64` and the list is controlled by
    // taskcluster/kinds/module-build/kind.yml
    //
    // For libjnidispatch, we include all libraries included in the official JAR file.
    consumable("libsForTests")
    // Stores the JNA jar file
    jna {
        canBeConsumed = false
        canBeResolved = true
        canBeDeclared = true
    }
    // Native megazord library, this is the one compatible with the user's local machine.  We use it
    // to run uniffi-bindgen against.
    consumable("megazordNative")
}

dependencies {
    // Needed so we can copy the libraries into libsForTests.
    jna(libs.jna) {
        artifact {
            type = "jar"
        }
    }
}

// Extract JNI dispatch libraries from the JAR into a directory, so that we can then package them
// into our own megazord-desktopLibraries JAR.
def extractLibJniDispatch = tasks.register("extractLibJniDispatch", Copy) {
    from zipTree(configurations.jna.singleFile).matching {
        include "**/libjnidispatch.*"
    }
    into layout.buildDirectory.dir("libjnidispatch").get()
}

def packageLibsForTest = tasks.register("packageLibsForTest", Jar) {
    archiveBaseName = "full-megazord-libsForTests"

    from extractLibJniDispatch
    from layout.buildDirectory.dir("rustJniLibs/desktop")
    dependsOn tasks["cargoBuild${rootProject.ext.nativeRustTarget.capitalize()}"]
}

def copyMegazordNative = tasks.register("copyMegazordNative", Copy) {
    from layout.buildDirectory.dir("rustJniLibs/desktop")
    into layout.buildDirectory.dir("megazordNative")
}


artifacts {
    // Connect task output to the configurations
    libsForTests(packageLibsForTest)
    megazordNative(copyMegazordNative)
}

cargo {
    // The directory of the Cargo.toml to build.
    module = '..'

    // The Android NDK API level to target.
    apiLevel = rootProject.ext.build['minSdkVersion']

    // Where Cargo writes its outputs.
    targetDirectory = '../../../target'

    libname = 'megazord'

    // The Cargo targets to invoke.  The mapping from short name to target
    // triple is defined by the `rust-android-gradle` plugin.
    targets = rootProject.ext.rustTargets

    // Perform release builds (which should have debug info, due to
    // `debug = true` in Cargo.toml).
    profile = "release"

    exec = { spec, toolchain ->
        rootProject.ext.cargoExec(spec, toolchain)
        // Only used in the full megazord (that is, in this project) at build time.
        spec.environment("MEGAZORD_VERSION", rootProject.ext.library.version)
    }

    extraCargoBuildArguments = rootProject.ext.extraCargoBuildArguments
}

afterEvaluate {
    // The `cargoBuild` task isn't available until after evaluation.
    android.libraryVariants.all { variant ->
        def productFlavor = ""
        variant.productFlavors.each {
            productFlavor += "${it.name.capitalize()}"
        }
        def buildType = "${variant.buildType.name.capitalize()}"
        tasks["merge${productFlavor}${buildType}JniLibFolders"].dependsOn(tasks["cargoBuild"])
    }
}

apply from: "$rootDir/publish.gradle"
ext.configurePublish()

afterEvaluate {
    publishing {
        publications {
            // Publish a second package named `full-megazord-libsForTests` to Maven with the
            // `libsForTests` output.  This contains the same content as our `libsForTests`
            // configuration. Publishing it allows the android-components code to depend on it.
            libsForTests(MavenPublication) {
                artifact tasks['packageLibsForTest']
                artifact file("${projectDir}/../DEPENDENCIES.md"), {
                    extension "LICENSES.md"
                }
                pom {
                    groupId = rootProject.ext.library.groupId
                    artifactId = "${project.ext.artifactId}-libsForTests"
                    description = project.ext.description
                    // For mavenLocal publishing workflow, increment the version number every publish.
                    version = rootProject.ext.library.version + (rootProject.hasProperty('local') ? '-' + rootProject.property('local') : '')
                    packaging = "jar"

                    licenses {
                        license {
                            name = libLicense
                            url = libLicenseUrl
                        }
                    }

                    developers {
                        developer {
                            name = 'Sync Team'
                            email = 'sync-team@mozilla.com'
                        }
                    }

                    scm {
                        connection = libVcsUrl
                        developerConnection = libVcsUrl
                        url = libUrl
                    }
                }

                // This is never the publication we want to use when publishing a
                // parent project with us as a child `project()` dependency.
                alias = true
            }
        }
    }
}
