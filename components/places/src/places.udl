/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

[Wrapped]
typedef string Url;
[Wrapped]
typedef i64 Timestamp;
[Wrapped]
typedef i32 VisitTransitionSet;


namespace places {
    [Throws=PlacesError]
    PlacesApi places_api_new(string db_path);
};

enum ConnectionType {
    "ReadOnly",
    "ReadWrite",
    "Sync", // ideally we wouldn't need to expose this and should guard against it being used (it's internal only)
};

interface PlacesApi {
    [Throws=PlacesError]
    PlacesConnection new_connection(ConnectionType conn_type);
};

interface PlacesConnection {
    [Throws=PlacesError]
    HistoryMetadata? get_latest_history_metadata_for_url(Url url);

    [Throws=PlacesError]
    sequence<HistoryMetadata> get_history_metadata_between(Timestamp start, Timestamp end);

    [Throws=PlacesError]
    sequence<HistoryMetadata> get_history_metadata_since(Timestamp since);

    [Throws=PlacesError]
    sequence<HistoryMetadata> query_history_metadata(string query, i32 limit);

    [Throws=PlacesError]
    sequence<HistoryHighlight> get_history_highlights(HistoryHighlightWeights weights, i32 limit);

    [Throws=PlacesError]
    void note_history_metadata_observation(HistoryMetadataObservation data);

    [Throws=PlacesError]
    void metadata_delete(Url url, Url? referrer_url, string? search_term);

    [Throws=PlacesError]
    void metadata_delete_older_than(Timestamp older_than);

    [Throws=PlacesError]
    void apply_observation(VisitObservation visit);

    [Throws=PlacesError]
    sequence<Url> get_visited_urls_in_range(Timestamp start, Timestamp end, boolean include_remote);

    [Throws=PlacesError]
    sequence<HistoryVisitInfo> get_visit_infos(Timestamp start_date, Timestamp end_date, VisitTransitionSet exclude_types);

    [Throws=PlacesError]
    i64 get_visit_count(VisitTransitionSet exclude_types);

    [Throws=PlacesError]
    sequence<HistoryVisitInfo> get_visit_page(i64 offset, i64 count, VisitTransitionSet exclude_types);

    [Throws=PlacesError]
    HistoryVisitInfosWithBound get_visit_page_with_bound(i64 bound, i64 offset, i64 count, VisitTransitionSet exclude_types);

    [Throws=PlacesError]
    sequence<boolean> get_visited(sequence<string> urls);

    [Throws=PlacesError]
    void delete_visits_for(string url);

    [Throws=PlacesError]
    void delete_visits_between(Timestamp start, Timestamp end);

    [Throws=PlacesError]
    void delete_visit(string url, Timestamp timestamp);

    [Throws=PlacesError]
    sequence<TopFrecentSiteInfo> get_top_frecent_site_infos(i32 num_items, i64 frecency_threshold);
};

// Some kind of namespacing for uniffi would be ideal. Multiple udl/macro defns?
// Everything below is from the crate::storage::history_metadata module...

enum DocumentType {
     // A page that isn't described by any other more specific types.
    "Regular",
    // A media page.
    "Media",
};

enum VisitTransition {
    // This transition type means the user followed a link.
    "Link",
    // This transition type means that the user typed the page's URL in the
    // URL bar or selected it from UI (URL bar autocomplete results, etc)
    "Typed",
    "Bookmark",
    "Embed",
    "RedirectPermanent",
    "RedirectTemporary",
    "Download",
    "FramedLink",
    "Reload",
};

// This is used as an "input" to the api.
dictionary HistoryMetadataObservation {
    string url;
    string? referrer_url = null;
    string? search_term = null;
    i32? view_time = null;
    DocumentType? document_type = null;
    string? title = null;
};

// This is what is returned.
dictionary HistoryMetadata {
    string url;
    string? title;
    string? preview_image_url;
    i64 created_at;
    i64 updated_at;
    i32 total_view_time;
    string? search_term;
    DocumentType document_type;
    string? referrer_url;
};

dictionary HistoryHighlightWeights {
    double view_time;
    double frequency;
};

dictionary HistoryHighlight {
    double score;
    i32 place_id;
    string url;
    string? title;
    string? preview_image_url;
};

dictionary HistoryVisitInfo {
    Url url;
    string? title;
    Timestamp timestamp;
    // XXX - This should use the VisitType enum when it gets uniffied
    i32 visit_type;
    boolean is_hidden;
    Url? preview_image_url;
};

dictionary HistoryVisitInfosWithBound {
    sequence<HistoryVisitInfo> infos;
    i64 bound;
    i64 offset;
};

/**
 * Encapsulates either information about a visit to a page, or meta information about the page,
 * or both. Use [VisitType.UPDATE_PLACE] to differentiate an update from a visit.
 */
dictionary VisitObservation {
    string url;
    string? title = null;
    VisitTransition? visit_type;
    boolean? is_error = null;
    boolean? is_redirect_source = null;
    boolean? is_permanent_redirect_source = null;
    Timestamp? at = null;
    string? referrer = null;
    boolean? is_remote = null;
    string? preview_image_url = null;
};

// Exists just to convince uniffi to generate `liftSequence*` helpers!
dictionary Dummy {
    sequence<HistoryMetadata>? md;
};

dictionary TopFrecentSiteInfo {
    Url url;
    string? title;
};


[Error]
enum PlacesError {
    "UnexpectedPlacesException",
    "UrlParseFailed",
    "PlacesConnectionBusy",
    "OperationInterrupted",
    "BookmarksCorruption",
    "InvalidParent",
    "UnknownBookmarkItem",
    "UrlTooLong",
    "InvalidBookmarkUpdate",
    "CannotUpdateRoot",
    "InternalPanic",
};
