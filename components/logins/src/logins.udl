/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

namespace logins {
    // We expose the crypto primitives on the namespace

    // Create a new, random, encryption key.
    [Throws=LoginsStorageError]
    string create_key();

    // Decrypt an `EncryptedLogin` to a `Login`
    [Throws=LoginsStorageError]
    Login decrypt_login(EncryptedLogin login, [ByRef]string encryption_key);

    // Encrypt a `Login` to an `EncryptedLogin`
    [Throws=LoginsStorageError]
    EncryptedLogin encrypt_login(Login login, [ByRef]string encryption_key);

    // Decrypt an encrypted `string` to `SecureLoginFields`
    [Throws=LoginsStorageError]
    SecureLoginFields decrypt_fields(string sec_fields, [ByRef]string encryption_key);

    // Encrypt `SecureLoginFields` to an encrypted `string`
    [Throws=LoginsStorageError]
    string encrypt_fields(SecureLoginFields sec_fields, [ByRef]string encryption_key);

    Login? find_login_to_update([ByRef]LoginEntry look, [ByRef]sequence<Login> logins);

    // XXX - we still need some way to have a "canary" for the encryption_key - eg, to ensure
    // a given key is the correct key for the DB. `autofill` consumers do this by just encrypting
    // some arbitrary string and storing the ciphertext, and as the app starts and the ciphertext
    // is loaded, it checks the string decrypts.
    // However, we don't otherwise need encryption and decryption of arbitrary strings. An
    // alternative is we expose a specific `check_canary` or similar function, and we manage
    // storage of the strings etc in our meta table?
};

// The fields you can add or update.
dictionary LoginFields {
    string origin;
    string? http_realm;
    string? form_action_origin;
    string username_field;
    string password_field;
};

// Fields available only while the encryption key is known.
dictionary SecureLoginFields {
    string password;
    string username;
};

// Fields specific to database records
dictionary RecordFields {
    string id;
    i64 times_used;
    i64 time_created;
    i64 time_last_used;
    i64 time_password_changed;
};

// A login entry from the user, not linked to any database record.
// The add/update APIs input these, alongside an encryption key.
dictionary LoginEntry {
    LoginFields fields;
    SecureLoginFields sec_fields;
};

// A login stored in the database
dictionary Login {
    RecordFields record;
    LoginFields fields;
    SecureLoginFields sec_fields;
};

// An encrypted version of [Login].  This is what we return for all the "read"
// APIs - we never return the cleartext of encrypted fields.
dictionary EncryptedLogin {
    RecordFields record;
    LoginFields fields;
    string sec_fields; // ciphertext of a SecureLoginFields
};

[Error]
enum LoginsStorageError {
    "UnexpectedLoginsStorageError",
    "SyncAuthInvalid",
    "MismatchedLock",
    "NoSuchRecord",
    "InvalidRecord",
    "CryptoError",
    "InvalidKey",
    "RequestFailed",
    "Interrupted",
};

interface LoginStore {
    [Throws=LoginsStorageError]
    constructor(string path);

    // XXX - Can we kill this, and just fix the semantics of add/update?
    [Throws=LoginsStorageError]
    void check_valid_with_no_dupes([ByRef] string id, [ByRef] LoginEntry login, [ByRef] string encryption_key);

    [Throws=LoginsStorageError]
    EncryptedLogin add(LoginEntry login, [ByRef]string encryption_key);

    [Throws=LoginsStorageError]
    EncryptedLogin update([ByRef] string id, LoginEntry login, [ByRef]string encryption_key);

    [Throws=LoginsStorageError]
    EncryptedLogin add_or_update(LoginEntry login, [ByRef]string encryption_key);

    [Throws=LoginsStorageError]
    boolean delete([ByRef] string id);

    [Throws=LoginsStorageError]
    void wipe();

    [Throws=LoginsStorageError]
    void wipe_local();

    [Throws=LoginsStorageError, Self=ByArc]
    void reset();

    [Throws=LoginsStorageError]
    void touch([ByRef] string id);

    [Throws=LoginsStorageError]
    sequence<EncryptedLogin> list();

    [Throws=LoginsStorageError]
    sequence<EncryptedLogin> get_by_base_domain([ByRef] string base_domain);

    // XXX - Can we kill this, and just fix the semantics of add/update?
    [Throws=LoginsStorageError]
    sequence<EncryptedLogin> potential_dupes_ignoring_username([ByRef]string id, LoginEntry login);

    [Throws=LoginsStorageError]
    EncryptedLogin? get([ByRef] string id);

    [Throws=LoginsStorageError]
    string import_multiple(sequence<Login> login, [ByRef]string encryption_key);

    [Self=ByArc]
    void register_with_sync_manager();

    [Throws=LoginsStorageError, Self=ByArc]
    string sync(string key_id, string access_token, string sync_key, string tokenserver_url, string local_encryption_key);
};
